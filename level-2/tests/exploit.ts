import * as anchor from "@coral-xyz/anchor";
import { web3 } from "@coral-xyz/anchor";
import { assert } from "chai";

import { Program } from "@coral-xyz/anchor";
import { Level2 } from "../target/types/level_2";


const SECRET1 = "f12204deadbe4fb5bbf232ddaed88052d91739ef21245437dc41de016e06c7f5"
const SECRET2 = "81e538870547130f1418f79a6a8bd378e1e21c5ad6d5e27ef6e6c478fac44714"


describe("level-2", () => {
  // Configure the client to use the local cluster.
  let provider = anchor.AnchorProvider.env();

  anchor.setProvider(provider);

  const program = anchor.workspace.Level2 as Program<Level2>;


  anchor.setProvider(provider);

  const user1 = web3.Keypair.generate();
  const user2 = web3.Keypair.generate();
  const [player1_account] = web3.PublicKey.findProgramAddressSync([Buffer.from("EXPLORER"), user1.publicKey.toBuffer()], program.programId);
  const [player2_account] = web3.PublicKey.findProgramAddressSync([Buffer.from("EXPLORER"), user2.publicKey.toBuffer()], program.programId);

  before("Fund the users!", async () => {
    await airdrop(provider.connection, user1.publicKey);
    await airdrop(provider.connection, user2.publicKey);
  });

  it("Setup players!", async () => {
    await program.methods.initExplorer(SECRET1, SECRET2)
      .accounts({ user: user1.publicKey, explorerAccount: player1_account, systemProgram: web3.SystemProgram.programId })
      .signers([user1])
      .rpc({ commitment: "confirmed" });

    await program.methods.initExplorer(SECRET1, SECRET2)
      .accounts({ user: user2.publicKey, explorerAccount: player2_account, systemProgram: web3.SystemProgram.programId })
      .signers([user2])
      .rpc({ commitment: "confirmed" });
  });

  it("implements the series of ix to gain the maximum exp", async () => {

    // await fight("P1")
    // await fight("P1")
    // await heal(false)
    // await fight("P1")
    // await fight("P1")
    // await heal(true)
    // await fight("P2")
    // await fight("P2")
    // // await healP2(true)

    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await heal(true);
    await fight("P1")
    await fight("P1")
    await heal(false)
    await fight("P1")
    await fight("P1")

    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await healP2(true);
    await fight("P2")
    await fight("P2")
    await healP2(false)
    await fight("P2")
    await fight("P2")


    
    console.log("Player 1 stats after the whole fight::", await player_stats(program, player1_account))
    console.log("Player 2 stats after the whole fight::", await player_stats(program, player2_account))

  })

  it("Exploit evaluation", async () => {

    const txSignature = await program.methods.revealSecret().accounts({
      user1: user1.publicKey,
      user2: user2.publicKey,
      explorer1Account: player1_account,
      explorer2Account: player2_account,
    }).signers([user1, user2]).rpc({ commitment: "confirmed" })

    await logTxn(provider.connection, txSignature)

  });


  async function heal(healSelf: boolean) {
    if (healSelf) {
      await program.methods.healAlly()
        .accountsStrict({
          healer: player1_account,
          injuredExplorer: player1_account,
          user: user1.publicKey
        })
        .signers([user1])
        .rpc({
          commitment: "confirmed"
        });
    } else {
      await program.methods.healAlly()
        .accountsStrict({
          healer: player2_account,
          injuredExplorer: player1_account,
          user: user2.publicKey
        })
        .signers([user2])
        .rpc({
          commitment: "confirmed"
        });

    }
  }

  async function healP2(healSelf: boolean) {
    if (healSelf) {
      await program.methods.healAlly()
        .accountsStrict({
          healer: player2_account,
          injuredExplorer: player2_account,
          user: user2.publicKey
        })
        .signers([user2])
        .rpc({
          commitment: "confirmed"
        });
    } else {
      await program.methods.healAlly()
        .accountsStrict({
          healer: player1_account,
          injuredExplorer: player2_account,
          user: user1.publicKey
        })
        .signers([user1])
        .rpc({
          commitment: "confirmed"
        });

    }
  }

  async function fight(who: "P1" | "P2") {
    let accounts;
    let signer
    if (who == "P1") {
      accounts = {
        explorerAccount: player1_account,
        user: user1.publicKey
      } 
      signer = user1
    } else {
      accounts = {
        explorerAccount: player2_account,
        user: user2.publicKey
      }
      signer = user2
    }
    await program.methods.battleMonster()
      .accountsStrict(accounts)
      .signers([signer])
      .rpc({
        commitment: "confirmed"
      });

  }

});



async function airdrop(connection: any, address: any, amount = 1000000000) {
  await connection.confirmTransaction(await connection.requestAirdrop(address, amount), "confirmed");
}

async function player_stats(program: any, player_account: any) {
  const playerData = await program.account.explorer.fetch(
    player_account,
    "confirmed"
  );
  return `
  \t- Mana: \x1b[94m\x1b[1m${playerData.mana}\x1b[0m,
  \t- Health: \x1b[32m\x1b[1m${playerData.health}\x1b[0m,
  \t- Experience: \x1b[93m\x1b[1m${playerData.experience}\x1b[0m,
  \t- Monsters Killed: \x1b[91m\x1b[1m${playerData.monstersDefeated}\x1b[0m`;
}


async function logTxn(connection: anchor.web3.Connection, txSignature: any) {
  // Confirm the transaction to ensure it's finalized
  const latestBlockhash = await connection.getLatestBlockhash();
  await connection.confirmTransaction(
    {
      signature: txSignature,
      blockhash: latestBlockhash.blockhash,
      lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
    },
    "confirmed"
  );

  // Retrieve the transaction details
  const txDetails = await connection.getTransaction(txSignature, {
    commitment: "confirmed",
    maxSupportedTransactionVersion: 0,
  });

  const logs = txDetails?.meta?.logMessages;

  if (logs) {
    console.log("Transaction Logs:");
    logs.forEach((log) => console.log(log));
  } else {
    console.log("No logs found for this transaction.");
  }
}